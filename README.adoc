:toc: preamble

# Spring Test MongoDb

image:https://travis-ci.com/antkorwin/spring-test-mongo.svg?branch=master["Build Status", link="https://travis-ci.com/antkorwin/spring-test-mongo"]
image:https://codecov.io/gh/antkorwin/spring-test-mongo/branch/master/graph/badge.svg[link ="https://codecov.io/gh/antkorwin/spring-test-mongo"]

Tools to write integration tests of applications with a MongoDb persistance layer and Spring Framework.


## Introduction

SpringTestMongo is a tool to write integration tests on systems which
used the MongoDB as a data storage.
This library provides you an ability to run your tests with the docker
image of MongoDB (by the use of Testcontainers).

Also, spring-test-mongo allows you to write tests in a more pragmatic
manner using annotations and extension for JUnit5.
Also, this library supports the JUnit4 by the using a Rule approach.
You can use JSON files to prepare the state of a database
or to check this state after some activities (update, delete e.t.c).

## Getting started

You need to add next dependencies:

[source, xml]
----
<dependency>
    <groupId>com.github.antkorwin</groupId>
    <artifactId>spring-test-mongo</artifactId>
    <version>0.11</version>
</dependency>
----

And repository:

[source, xml]
----
<repositories>
	<repository>
		<id>jitpack.io</id>
		<url>https://jitpack.io</url>
	</repository>
</repositories>
----

## JUnit5 integration test

Let's look at the example of using the TestContainers library to make integration tests.
And the JUnit5 extension to make your tests more pragmatic and elegant.


[source, java]
----
@MongoDbIntegrationTest <1>
class JUnit5ExampleTest {

    @Autowired
    private MongoTemplate mongoTemplate;

    @Test
    @MongoDataSet(value = "/dataset/bar_dataset.json")  <2>
    void testPopulatingByMongoDataSet() throws Exception {

        Bar simpleDoc = mongoTemplate.findById("55f3ed00b1375a48e618300b", Bar.class);  <3>

        Assertions.assertThat(simpleDoc)
                  .isNotNull()
                  .extracting(Bar::getId, Bar::getData)
                  .containsOnly("55f3ed00b1375a48e618300b", "BB");
    }
}
----
<1> This annotation runs MongoDB instance by the use of Testcontainers library
and turn on SpringTestMongo which able you to use DataSets in tests
<2> Initialize the state of the database from JSON file before the test execute
<3> Read data from the MongoDB instance which started by the MongoDbIntegrationTest annotation



Let's look at the file with a data-set(`bar_dataset.json`):

[source, json]
----
{
  "com.antkorwin.springtestmongo.Bar": [
    {
      "id": "55f3ed00b1375a48e618300a",
      "data": "A"
    },
    {
      "id": "55f3ed00b1375a48e618300b",
      "data": "BB"
    }
  ]
}
----


## JUnit4 integration test

Also, you can use the JUnit4 rule and the base abstract class
to write integration tests in the old-style (with the use of the JUnit4 and inheritance in tests)

[source, java]
----
public class JUnit4ExampleTest extends BaseMongoIT {

    @Test
    @MongoDataSet(value = "/dataset/multidocument_dataset.json")
    public void testPopulatingByMongoDataSet() throws Exception {

        Bar simpleDoc = mongoTemplate.findById("55f3ed00b1375a48e618300b", Bar.class);

        Assertions.assertThat(simpleDoc)
                  .isNotNull()
                  .extracting(Bar::getId, Bar::getData)
                  .containsOnly("55f3ed00b1375a48e618300b", "BB");
    }
}
----

## Using dynamic values in datasets

### Using GroovyScript in datasets

To use Groovy scriptable datasets you need to add the next dependency:

[sourcce, xml]
----
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-all</artifactId>
    <version>2.4.6</version>
    <scope>test</scope>
</dependency>
----

Let's look at the next document:

[source, java]
----
@Document
public class Task {

    @Id
    private String id;
    private String title;
    private int estimate;
    private Date createTime;
}
----

You can write groovy scripts in the values of fields:

[source, json]
----
{
  "com.antkorwin.springtestmongoexamples.model.Task": [
    {
      "id": "55f3ed00b1375a48e618300a",
      "title": "black magic",
      "estimate": "groovy: (1..5).sum()",
      "createTime": "groovy: new Date(12345)"
    }
  ]
}
----

And now you can write the next test with expected values of this fields:

[source, java]
----
@Test
@MongoDataSet(cleanBefore = true, cleanAfter = true,
              value = "dataset/init_task_groovy.json")
void groovyInitTest() {
    Task task = taskService.get("55f3ed00b1375a48e618300a");
    assertThat(task).extracting(Task::getEstimate, Task::getCreateTime)
                    .contains(1 + 2 + 3 + 4 + 5, new Date(12345));
}
----


### Using JavaScript in datasets

Unlike Groovy scripts, Javascript comes by default in JDK and you don't need some extra dependencies to work with JavaScript.

Let's consider the next simple document class:

[source, java]
----
@Document
public class Bar {
    @Id
    private String id;
    private String data;
}
----

and make the dataset file `javascript-dataset.json`:

[source, json]
----
{
   "com.antkorwin.springtestmongo.Bar": [
     {
       "id": "55f3ed00b1375a48e618300a",
       "data": "js: 2+3"
     }
   ]
}
----

And now we expecting a successful result of this test:

[source, java]
----
public class JUnit4ExampleTest extends BaseMongoIT {

    @Test
    @MongoDataSet(value = "javascript-dataset.json")
    public void jsDataset() throws Exception {

        Bar simpleDoc = mongoTemplate.findById("55f3ed00b1375a48e618300a", Bar.class);

        Assertions.assertThat(simpleDoc)
                  .isNotNull()
                  .extracting(Bar::getData)
                  .containsOnly(5);
    }
}
----